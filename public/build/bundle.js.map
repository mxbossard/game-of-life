{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../src/iterated_prisoners_dilemma.js","../../src/game_theory_logic.js","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","\nclass Environment {\n\n    // Reset the environment\n    clear() {\n\n    }\n\n    // Spawn a new cell in the environment\n    spawn(cell) {\n\n    }\n\n    // The supplied cell vill give birth to a new cell.\n    giveBirth(cell) {\n\n    }\n\n    // The supplied cell will be killed.\n    kill(cell) {\n\n    }\n\n    // Process a combat between 2 cells. If combat already done, do nothing.\n    fight(cell1, cell2) {\n\n    }\n\n    // Check if a cell is super adapted to it's environment\n    isSuperAdapted(cell) {\n\n    }\n\n    // Check if a cell is adapted to it's environment\n    isAdapted(cell) {\n\n    }\n\n    // Advance by one generation returning 2 arrays of born and dead cells.\n    step() {\n\n    }\n\n}\n\nfunction Strategy() {\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n\n    }\n}\n\nclass Cell {\n\n    constructor(c, r, strategy) {\n        this.c = c;\n        this.r = r;\n        this.strategy = strategy;\n        this.alive = true;\n    }\n\n    key() {\n        return Helper.cellKey(this.c, this.r);\n    }\n\n    static parse(cellString) {\n        return Helper.parseCell(cellString);\n    }\n}\n\nclass IpdScore {\n\n    constructor(cell) {\n        this.cell = cell;\n        this.fightCount = 0;\n        this.winByStrategyCount = new Map(); // Map strategyName > int\n        this.scoreByStrategyCount = new Map(); // Map strategyName > int\n        this.winCount = 0;\n        this.score = 0;\n    }\n\n    addScore(score, versusCell, versusScore) {\n        this.fightCount ++;\n        if (score) this.score += score;\n        if (score > versusScore) this.winCount ++;\n\n        let byStratCounter = (this.winByStrategyCount.get(versusCell.strategy.name) || 0);\n        this.winByStrategyCount.set(versusCell.strategy.name, byStratCounter + 1);\n\n        let byStratScore = (this.scoreByStrategyCount.get(versusCell.strategy.name) || 0);\n        this.scoreByStrategyCount.set(versusCell.strategy.name, byStratScore + versusScore);\n    }\n\n    isGreaterThan(otherScore) {\n        if (!otherScore) return true;\n        if (this.score > otherScore.score) return true; // The highest score win\n        if (this.fightCount > otherScore.fightCount) return true; // The veteran win\n\n        return false;\n    }\n}\n\nclass Helper {\n\n    static cellKey(c, r) {\n        return c + ';' + r; //+ ';' + cell.strategy.name\n    }\n\n    static parseCell(cellString) {\n        //const [r, c, strategy] = cellString.split(';')\n        //return {r:parseInt(r, 10), c:parseInt(c, 10), strategy: strategy}\n        const [c, r] = cellString.split(';');\n        return {r:parseInt(r, 10), c:parseInt(c, 10)};\n    }\n\n    static fightKey(cell1, cell2) {\n        let key = Helper.cellKey(cell1.c, cell1.r) + '_' + Helper.cellKey(cell2.c, cell2.r);\n        //let key = Helper.cellKey(cell1.c, cell1.r) + '_' + Helper.cellKey(cell2.strategy.name); // Do only one fight by strategy.\n        return key;\n    }\n\n    static initArena() {\n        let spacing = 10;\n        let baseDiameter = 2;\n\n        let stratCounts = strategies.length;\n        let replicaCounts = stratCounts * 2// * (stratCounts);\n        let alpha = 2 * Math.PI / replicaCounts;\n\n        let arenaDiameter = spacing * replicaCounts / (2 * Math.PI);\n\n        /*\n        for (let i = 0; i < stratCounts; i++) {\n            for (let j = 0; j < stratCounts - 1; j++) {\n                let x = Math.ceil(Math.cos((i + j * (stratCounts)) * alpha) * arenaDiameter);\n                let y = Math.ceil(Math.sin((i + j * (stratCounts)) * alpha) * arenaDiameter);\n                \n                for (let dx = Math.floor(-baseDiameter/2) ; dx <= baseDiameter/2; dx ++) {\n                    for (let dy = Math.floor(-baseDiameter/2) ; dy <= baseDiameter/2; dy ++) {\n                        let dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n                        if(dist <= baseDiameter/2) {\n                            let cell = new Cell(x + dx, y + dy, strategies[(i + j) % strategies.length]);\n                            environment.spawn(cell);\n                        }\n                    }\n                }\n            }\n        }\n        */\n\n        for (let k = 0; k < replicaCounts; k++) {\n            let x = Math.ceil(Math.cos(k * alpha) * arenaDiameter);\n            let y = Math.ceil(Math.sin(k * alpha) * arenaDiameter);\n\n            let indice = Math.floor(k / strategies.length);\n            let position = (indice+1) * strategies.length - (indice) * (Math.round((strategies.length) * 1 / 2)) + (k%strategies.length) * Math.pow(-1, indice) - Math.floor(indice*3/2);\n            console.debug('k:', k, 'indice:', indice, 'position:', position);\n\n            for (let dx = Math.floor(-baseDiameter/2) ; dx <= baseDiameter/2; dx ++) {\n                for (let dy = Math.floor(-baseDiameter/2) ; dy <= baseDiameter/2; dy ++) {\n                    let dist = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n                    if(dist <= baseDiameter/2) {\n                        \n                        let cell = new Cell(x + dx, y + dy, strategies[position % strategies.length]);\n                        environment.spawn(cell);\n                    }\n                }\n            }\n        }\n    }\n}\n\nexport const COOPERATE = 'COOPERATE';\nexport const DEFECT = 'DEFECT';\n//const NEIGHBORHOOD = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];\nconst NEIGHBORHOOD = [[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]]; // 8 surronding boxes from 12 oclock\n\n// Tous les combats sont \"reversibles\". On ne joue que \"la moitié\" des combats.\nclass IteratedPrisonersDilemmaEnvironment {\n\n    constructor(roundCount, boundary) {\n        this.roundCount = roundCount;\n        this.livings = new Map(); // Map of living cell : cellKey > Cell\n        this.neigborhoodsMap = new Map(); // Map of neighbor cells : cellKey > [[neighborCellsLvl0], [neighborCellsLvl1], ...]\n        this.fightsDone = new Set(); // Set of fightKey\n        this.scoreboard = new Map(); // Map of score : cellKey > Score\n        this.leaderboard = []; // Array of Cell\n        this.fightResultCacheDisabled = false;\n        this.fightResultCache = new Map(); // Map of fitht result : strat1;strat2 > [counter, counter]\n        this.boundary = boundary;\n    }\n\n    // Reset the environment\n    clear() {\n        this.livings = new Map();\n        this.fightsDone = new Set();\n        this.scoreboard = new Map();\n        this.leaderboard = [];\n\n        Helper.initArena();\n    }\n\n    spawn(cell) {\n        //console.debug('Spawning new Cell:', cell.key());\n\n        let key = cell.key();\n        if (this.livings.has(key)) {\n            throw new Error('Trying to spawn a cell on a living cell !');\n        }\n\n        this.livings.set(key, cell);\n    }\n\n    // Return the neighborhoods keys of a cell : an array of levels neighbors discribed by their cellKey.\n    neigborhoodsKeys(cell) {\n        let cellKey = cell.key();\n        if (this.neigborhoodsMap.has(cellKey)) {\n            return this.neigborhoodsMap.get(cellKey);\n        }\n\n        let neighborhood = [];\n        let distancesToCenter = [];\n        for (let [dc, dr] of NEIGHBORHOOD) {\n            let nr = cell.r + dr;\n            let nc = cell.c + dc;\n            let midDistanceToCenter = Math.sqrt(Math.pow(cell.c, 2) + Math.pow(cell.r, 2));\n            let distanceToCenter = Math.sqrt(Math.pow(nc, 2) + Math.pow(nr, 2));\n            let reducedDistanceToCenter = 3 + distanceToCenter - midDistanceToCenter;\n            //distancesToCenter.push([reducedDistanceToCenter, distanceToCenter, nc, nr]);\n            distancesToCenter.push([reducedDistanceToCenter, distanceToCenter, nc, nr]);\n        }\n        distancesToCenter.sort();\n\n        for (let [reduced, dist, nc, nr] of distancesToCenter) {\n            if (this.boundary > 0 && (nc > this.boundary || nc < -this.boundary | nr > this.boundary || nr < -this.boundary)) {\n                // neighboor outside of boundaries.\n            } else {\n                let ncellKey = Helper.cellKey(nc, nr);\n                neighborhood.push(ncellKey);\n            }\n        }\n\n        let neighborhoods = [neighborhood];\n        this.neigborhoodsMap.set(cellKey, neighborhoods);\n        //console.debug('neighborhoods:', neighborhoods);\n        return neighborhoods;\n    }\n\n    // A cell give birth to some Cells, returning the new cells. Do not spwn any cell.\n    giveBirth(cell) {\n        let babies = [];\n        let [neighborhood] = this.neigborhoodsKeys(cell);\n        for (let neighborKey of neighborhood) {\n            if (this.livings.has(neighborKey)) {\n                // neighbor is alive. Do not give birth here.\n                //console.debug('someone is living here !');\n            } else {\n                // neighbor is not alive. Give birth here.\n                let nCell = Helper.parseCell(neighborKey);\n                //console.debug('neighborKey:', neighborKey, 'nCell:', nCell);\n                let baby = new Cell(nCell.c, nCell.r, cell.strategy);\n                //console.debug('A new baby:', baby);\n                babies.push(baby);\n                break;\n            }\n        }\n\n        //console.debug('Giving birth to cell:', cell, 'with babies:', babies);\n        return babies;\n    }\n\n    kill(cell) {\n        let key = cell.key();\n        this.livings.delete(key);\n    }\n\n    // Process a combat between 2 cells. If combat already done, do nothing.\n    fight(cell1, cell2) {\n        let fightKey = Helper.fightKey(cell1, cell2);\n        if (this.fightsDone.has(fightKey)) return;\n\n        let strategy1Counter = 0;\n        let strategy2Counter = 0;\n\n        let fightingStratsKey = cell1.strategy.name + ';' + cell2.strategy.name;\n        if (!this.fightResultCache.has(fightingStratsKey) || this.fightResultCacheDisabled) {\n            // Do the fight anc cache it's results.\n            //console.debug('FIGHT: ', cell1.key(), 'vs', cell2.key());\n\n            let strategy1 = cell1.strategy;\n            let strategy2 = cell2.strategy;\n            \n            let strategy1Plays = [];\n            let strategy2Plays = [];\n            for (let i = 0; i < this.roundCount; i++) {\n                let play1 = strategy1.play(i, strategy1Plays, strategy2Plays, this.roundCount);\n                let play2 = strategy2.play(i, strategy2Plays, strategy1Plays, this.roundCount);\n\n                strategy1Plays.push(play1);\n                strategy2Plays.push(play2);\n\n                if (play1 == COOPERATE && play2 == COOPERATE) {\n                    // 3 points for everyone\n                    strategy1Counter += 3;\n                    strategy2Counter += 3;\n                } else if (play1 == COOPERATE && play2 == DEFECT) {\n                    // 0 point for strategy1 ; 5 points for strategy 2\n                    strategy2Counter += 5;\n                } else if (play1 == DEFECT && play2 == COOPERATE) {\n                    // 5 points for strategy1 ; 0 point for strategy 2\n                    strategy1Counter += 5;\n                } else if (play1 == DEFECT && play2 == DEFECT) {\n                    // 1 point for strategy1 ; 1 point for strategy 2\n                    strategy1Counter += 1;\n                    strategy2Counter += 1;\n                } else {\n                    throw new Error('Not supported play [', + play1 + ' ; ' + play2 + '] for strategies [' + strategy1.name + ' ; ' + strategy2.name + '] !');\n                }\n            }\n            \n            //console.debug('Cell1 get', strategy1Counter, 'points ; Cell2 get', strategy2Counter, 'points.');\n\n            this.fightResultCache.set(fightingStratsKey, [strategy1Counter, strategy2Counter]);\n        } else {\n         [strategy1Counter, strategy2Counter] = this.fightResultCache.get(fightingStratsKey);\n        }\n\n        let score1 = (this.scoreboard.get(cell1.key()) || new IpdScore(cell1))\n        score1.addScore(strategy1Counter, cell2, strategy2Counter);\n        this.scoreboard.set(cell1.key(), score1);\n\n        let score2 = (this.scoreboard.get(cell2.key()) || new IpdScore(cell2))\n        score2.addScore(strategy2Counter, cell1, strategy1Counter);\n        this.scoreboard.set(cell2.key(), score2);\n\n        // Fights are symetric so add 2 fights to set of done fights.\n        this.fightsDone.add(Helper.fightKey(cell1, cell2));\n        // FIXME: With only one fight by strategy, fight are no more symetric.\n        this.fightsDone.add(Helper.fightKey(cell2, cell1));\n    }\n\n    isDying(cell) {\n        let score = this.scoreboard.get(cell.key());\n        if (!score) return true;\n        let [neighborhood] = this.neigborhoodsKeys(cell);\n        let sameStratCount = 0;\n        let localTotalScore = score.score;\n        let neighborByStratCountMap = new Map();\n        for (let i = 0; i < neighborhood.length; i++) {\n            let neighborKey = neighborhood[i];\n            if (this.livings.has(neighborKey)) {\n                let neighbor = this.livings.get(neighborKey);\n                if (cell.strategy.name === neighbor.strategy.name) {\n                    sameStratCount ++;\n                }\n\n                let count = neighborByStratCountMap.get(neighbor.strategy.name) || 0;\n                neighborByStratCountMap.set(neighbor.strategy.name, count + 1);\n            }\n\n            let nScore = this.scoreboard.get(neighborKey);\n            if (nScore) localTotalScore += nScore.score;\n        }\n\n        //console.debug('sameStratCount: ', sameStratCount);\n        if (sameStratCount === 0) return true; // Die if alone.\n\n        let neighborByStratCounts = Array.from(neighborByStratCountMap.values());\n\n        // Die if a strategie cumul more point than our strategy.\n        let badScoreVersusStrat = false;\n        neighborByStratCountMap.forEach((neighborCount, strat, map) => {\n            //if (sameStratCount <= neighborCount) {\n                // if more foes than firends.\n                //return score.score < localTotalScore/(neighborhood.length + 1); // Die if score < mean.\n                badScoreVersusStrat = badScoreVersusStrat || score.scoreByStrategyCount.get(cell.strategy.name) < score.scoreByStrategyCount.get(strat);\n            //}\n        });\n        if (badScoreVersusStrat) return true;\n\n        //console.debug('neighborByStratCounts:', neighborByStratCounts);\n        for (let i = 0; i < neighborByStratCounts.length; i++) {\n            if (sameStratCount < neighborByStratCounts[i]) {\n                // if more foes than firends.\n\n                return score.score < localTotalScore/(neighborhood.length + 1); // Die if score < mean.\n            }\n        }\n\n        //console.debug('score: ', score.score, '/', localTotalScore);\n        return score.score < localTotalScore/(neighborhood.length + 1) * 8/10; // Die if score < 2/3 of mean score.\n    }\n\n    isGivingBirth(cell) {\n        let score = this.scoreboard.get(cell.key());\n        if (!score) return false;\n        let [neighborhood] = this.neigborhoodsKeys(cell);\n        let sameStratCount = 0;\n        let localTotalScore = score.score;\n        for (let i = 0; i < neighborhood.length; i++) {\n            let neighborKey = neighborhood[i];\n            if (this.livings.has(neighborKey)) {\n                let neighbor = this.livings.get(neighborKey);\n                if (cell.strategy === neighbor.strategy) {\n                    sameStratCount ++;\n                }\n            }\n\n            let nScore = this.scoreboard.get(neighborKey);\n            if (nScore) localTotalScore += nScore.score;\n        }\n        return sameStratCount > 2 && score.score >= localTotalScore/(neighborhood.length + 1); // Give birth if good score and there is 2 cells\n    }\n\n    // Check if a cell is adapted to it's environment\n    isAdapted(cell) {\n        let score = this.scoreboard.get(cell.key());\n        if (!score) return false;\n        let [neighborhood] = this.neigborhoodsKeys(cell);\n        for (let neighborKey of neighborhood) {\n            let nScore = this.scoreboard.get(neighborKey);\n        }\n\n\n        if (this.scoreboard.has(cell.key())) {\n            let score = this.scoreboard.get(cell.key());\n            \n            //return score.winCount > 4 || score.score > 8 * 1 * this.roundCount;\n            //return score.score > 8 * 1 * this.roundCount;\n            //return score > 8 * 1 * this.roundCount;\n            //return score.score > score.fightCount * 1 * this.roundCount * 7 / 6;\n            //return score.score > score.fightCount * 1 * this.roundCount * 15 / 12;\n\n            if (score.fightCount <= 1 ) return true;\n\n            let dc, dr, nc, nr, ncellKey;\n            let level = 0;\n            for ([dc, dr] of NEIGHBORHOOD) {\n                nr = cell.r + dr;\n                nc = cell.c + dc;\n                ncellKey = Helper.cellKey(nc, nr);\n                let ncellScore = this.scoreboard.get(ncellKey);\n                //console.debug('ncellScore:', ncellScore);\n                if (ncellScore && score.isGreaterThan(ncellScore)) {\n                    level++;\n                }\n            }\n\n            //console.debug('cell:', cell.key(), 'fights:', score.fightCount, 'rank:', rank);\n            return level > score.fightCount - 2;\n        } else {\n            throw new Error('Cell do not have a score !');\n        }\n    }\n\n    step() {\n        let self = this;\n        let givingBirths = [];\n        let births = [];\n        let deaths = [];\n        this.fightsDone = new Set();\n        this.scoreboard = new Map();\n        this.leaderboard = [];\n        this.fightResultCache = new Map();\n\n        let dr, dc, nr, nc, ncell, neighbor;\n        this.livings.forEach((cell, key, map) => {\n            for ([dc, dr] of NEIGHBORHOOD) {\n                nr = cell.r + dr;\n                nc = cell.c + dc;\n                ncell = Helper.cellKey(nc, nr);\n                if (this.livings.has(ncell)) {\n                    // neighbor is alive. Fight against it !\n                    neighbor = this.livings.get(ncell);\n                } else {\n                    // neighbor is not alive. Treat it as a dummy random.\n                    neighbor = new Cell(nc, nr, RANDOM_STRATEGY);\n                }\n\n                self.fight(cell, neighbor);\n            }\n        });\n\n        /*\n        console.info('livings: ', this.livings);\n        this.scoreboard.forEach((score, cellKey, map) => {\n            let key = cell.key();\n            if (!self.livings.has(key)) {\n                map.delete(cell);\n            } else {\n                self.leaderboard.push([score, key]);\n            }\n        });\n        console.info('scoreboard: ', this.scoreboard);\n        */\n\n        //let orderedScores = new Array(this.scoreboard.values).sort().reverse();\n\n        // FIXME: le leaderbord n'est pas ordonné numériquement ainsi !\n        //this.leaderboard.sort().reverse();\n        //console.info('leaderboard: ', this.leaderboard);\n\n        let babiesByParentMap = new Map();\n        let parentsByBabyMap = new Map(); // Map of babyCellKey > [concurrentsParentCell]\n        this.livings.forEach((cell, key, map) => {\n            if (self.isDying(cell)) {\n                deaths.push(cell);\n            } else\n            if (self.isGivingBirth(cell)) {\n                givingBirths.push(cell);\n                let babies = this.giveBirth(cell);\n                if (babies) {\n                    babiesByParentMap.set(cell, babies);\n                    babies.forEach(baby => {\n                        let babyKey = baby.key();\n                        let concurrentParrents;\n                        if (!parentsByBabyMap.has(babyKey)) {\n                            concurrentParrents = [];\n                            parentsByBabyMap.set(babyKey, concurrentParrents);\n                        } else {\n                            concurrentParrents = parentsByBabyMap.get(babyKey);\n                        }\n                        concurrentParrents.push(cell);\n                    });\n                }\n            }\n            \n            \n        });\n\n        parentsByBabyMap.forEach((concurrentParrents, babyKey, map) => {\n            // The parent with higher score win the baby cell !\n            let highestScore;\n            let winningCell;\n            concurrentParrents.forEach(cell => {\n                let score = this.scoreboard.get(cell.key());\n                if (score.isGreaterThan(highestScore)) {\n                    highestScore = score;\n                    winningCell = cell;\n                }\n            });\n            let babies = babiesByParentMap.get(winningCell);\n            babies.forEach(baby => {\n                this.spawn(baby);\n                births.push(baby);\n            });\n        });\n\n        deaths.forEach(cell => this.kill(cell));\n\n        console.info('births:', births);\n        console.info('deaths:', deaths);\n\n        return [births, deaths];\n    }\n\n}\n\nexport const environment = new IteratedPrisonersDilemmaEnvironment(100, 30);\n\nconst COOPERATIVE_STRATEGY = new CooperativeStrategy()\nfunction CooperativeStrategy() {\n    this.name = 'CooperativeStrategy';\n    this.color = 'forestgreen';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        return COOPERATE;\n    }\n}\n\nconst DEFECTIVE_STRATEGY = new DefectiveStrategy()\nfunction DefectiveStrategy() {\n    this.name = 'DefectiveStrategy';\n    this.color = 'red';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        return DEFECT;\n    }\n}\n\nconst DONNANT_DONNANT_STRATEGY = new DonnantDonnantStrategy()\nfunction DonnantDonnantStrategy() {\n    this.name = 'DonnantDonnantStrategy';\n    this.color = 'pink';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber == 0) return COOPERATE;\n        return otherPlays[roundNumber - 1];\n    }\n    \n}\n\nconst BAD_DONNANT_STRATEGY = new BadDonnantStrategy()\nfunction BadDonnantStrategy() {\n    this.name = 'BadDonnantStrategy';\n    this.color = 'purple';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber == 0) return DEFECT;\n        return otherPlays[roundNumber - 1];\n    }\n    \n}\n\nconst DOUBLE_DONNANT_STRATEGY = new DoubleDonnantStrategy()\nfunction DoubleDonnantStrategy() {\n    this.name = 'DoubleDonnantStrategy';\n    this.color = 'grey';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber < 2) return COOPERATE;\n        if (otherPlays[roundNumber - 1] == DEFECT && otherPlays[roundNumber - 2] == DEFECT) return DEFECT;\n        return COOPERATE;\n    }\n    \n}\n\nconst PER_CD_STRATEGY = new PerCDStrategy()\nfunction PerCDStrategy() {\n    this.name = 'PerCDStrategy';\n    this.color = 'yellow';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber % 2 == 0) return COOPERATE;\n        return COOPERATE;\n    }\n    \n}\n\nconst PER_CCD_STRATEGY = new PerCCDStrategy()\nfunction PerCCDStrategy() {\n    this.name = 'PerCCDStrategy';\n    this.color = 'lightgreen';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber % 3 < 2) return COOPERATE;\n        return DEFECT;\n    }\n    \n}\n\nconst PER_DDC_STRATEGY = new PerDDCStrategy()\nfunction PerDDCStrategy() {\n    this.name = 'PerDDCStrategy';\n    this.color = 'orange';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        if (roundNumber % 3 < 2) return DEFECT;\n        return COOPERATE;\n    }\n    \n}\n\nconst RANDOM_STRATEGY = new RandomStrategy()\nfunction RandomStrategy() {\n    let self = this;\n    this.name = 'RandomStrategy';\n    this.color = 'white';\n\n    this.plays = [];\n    for(let i = 0; i < environment.roundCount; i++) {\n        if (Math.random() * 2 < 2) {\n            self.plays.push(COOPERATE);\n        } else {\n            self.plays.push(DEFECT);\n        }\n    }\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        //return self.plays[roundNumber];\n        if (Math.random() * 2 < 2) return COOPERATE;\n        return DEFECT;\n    }\n}\n\nconst VOID_STRATEGY = new VoidStrategy()\nfunction VoidStrategy() {\n    this.name = 'VoidStrategy';\n    this.color = 'black';\n\n    // Return the move of the strategy\n    this.play = function(roundNumber, myPlays, otherPlays, roundCount) {\n        throw new Error('This strategy should not play !');\n    }\n}\n\n//const strategies = [DEFECTIVE_STRATEGY, COOPERATIVE_STRATEGY];\n//const strategies = [DEFECTIVE_STRATEGY, COOPERATIVE_STRATEGY,  DONNANT_DONNANT_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CCD_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_DDC_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY];\nconst strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY, DONNANT_DONNANT_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY, BAD_DONNANT_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY, PER_DDC_STRATEGY, DONNANT_DONNANT_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CCD_STRATEGY, DOUBLE_DONNANT_STRATEGY, PER_DDC_STRATEGY, DONNANT_DONNANT_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY, PER_DDC_STRATEGY];\n//const strategies = [COOPERATIVE_STRATEGY, DEFECTIVE_STRATEGY, PER_CD_STRATEGY, PER_CCD_STRATEGY, PER_DDC_STRATEGY, DONNANT_DONNANT_STRATEGY, DEFECTIVE_STRATEGY];\nHelper.initArena();","import { environment } from \"./iterated_prisoners_dilemma\";\n\nfunction GameTheory() {\n    let self = this;\n\n    // clear the grid\n    this.clear = function () {\n        environment.clear();\n    }\n\n    //get lists of cells that are born or die after a single step\n    this.step = function() {\n        return environment.step();\n    }\n\n    this.livingSet = function() {\n        return new Set(environment.livings.values());\n    }\n\n    this.isCellAlive = function(cell) {\n        throw new Error('Not supported yet !');\n    }\n\n    this.update = function(births, deaths) {\n        //throw new Error('Not supported yet !');\n    }\n\n\n}\n\nfunction Game() {\n    let self = this;\n    self.livingSet = new Set();\n    self.numNeighbors = new Map();\n\n    const neighborhood = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];\n\n    this.stringify = function(cell) {\n        return cell.r + ';' + cell.c + ';' + cell.strategy\n    }\n    this.parse = function(cellString) {\n        const [r, c] = cellString.split(';')\n        return {r:parseInt(r, 10), c:parseInt(c, 10)}\n    }\n\n    // check if a particular cell is alive\n    this.isCellAlive = function(cell) {\n        return self.livingSet.has(this.stringify(cell));\n    }\n\n    // clear the grid\n    this.clear = function () {\n        self.livingSet = new Set();\n        self.numNeighbors = new Map();\n    }\n\n    // update game grid\n    this.update = function(births, deaths) {\n        let dr, dc, nr, nc, n, ncell, deleted;\n        for (let cell of births) {\n            ncell = this.stringify(cell)\n            if (self.livingSet.has(ncell)) continue;\n            self.livingSet.add(ncell)\n            if (!(self.numNeighbors.has(ncell))) {\n                self.numNeighbors.set(ncell, 0)\n            }\n            for ([dr, dc] of neighborhood) {\n                nr = cell.r+dr;\n                nc = cell.c+dc;\n                ncell = this.stringify({r:nr, c:nc})\n                if (!self.numNeighbors.has(ncell)) {\n                    self.numNeighbors.set(ncell, 1)\n                } else {\n                    self.numNeighbors.set(ncell, self.numNeighbors.get(ncell)+1)\n                }\n            }\n        }\n        for (let cell of deaths) {\n            deleted = self.livingSet.delete(this.stringify(cell))\n            if (deleted) {\n                for ([dr, dc] of neighborhood) {\n                    nr = cell.r+dr;\n                    nc = cell.c+dc;\n                    ncell = this.stringify({r:nr, c:nc})\n                    n = self.numNeighbors.get(ncell)\n                    if ((n==1)&(!self.livingSet.has(ncell))) {\n                        self.numNeighbors.delete(ncell)\n                    } else {\n                        self.numNeighbors.set(ncell, n-1)\n                    }\n                }\n            }\n        }\n    }\n\n    //get lists of cells that are born or die after a single step\n    this.step = function() {\n        let births = [];\n        let deaths = [];\n        for (let [cell, num] of self.numNeighbors.entries()) {\n            if (self.livingSet.has(cell)) {\n                if ((num<2)|(num>3)) {deaths.push(this.parse(cell))}\n            } else {\n                if (num==3) {births.push(this.parse(cell))}\n            }\n        }\n        return [births, deaths]\n    }\n}\n\nexport const game = new GameTheory();\n","<script>\n    import { onMount } from 'svelte';\n    import { environment } from './iterated_prisoners_dilemma.js'\n    import { game } from './game_theory_logic.js'\n\n\n    const backgroundColor = 'black'\n    const foregroundColor = '#2bb'\n    const gridColor = '#555'\n    let canvasWidth, canvasHeight;\n\n    let cellSize = 25;\n    let centerX = 0.5;\n    let centerY = 0.5;\n\n    let canvas, context;\n    let stepTime = 0;\n    let drawTime = 0;\n\n    let timerId;\n    let speed = 10;\n    let running = false;\n    let drawing = false;\n    let drawAlive = true;\n    let helpVisible = false;\n\n    let mouseX, mouseY;\n    let numCells=0;\n\n    function clearCanvas() {\n        context.clearRect(0,0,canvas.width, canvas.height)\n        context.fillStyle = backgroundColor\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function drawGridLines() {\n        if (cellSize>=10) {\n            const dx = cellSize*(centerX-Math.floor(centerX))\n            const centerLeft = canvas.width/2 - dx\n            const firstLeft = centerLeft - cellSize*Math.floor(centerLeft/cellSize)\n\n            const dy = cellSize*(centerY-Math.floor(centerY))\n            const centerTop = canvas.height/2 - dy\n            const firstTop = centerTop - cellSize*Math.floor(centerTop/cellSize)\n\n            context.strokeStyle = gridColor\n            context.beginPath();\n            let h;\n            for (var i=0; i<Math.ceil(canvas.height/cellSize); i++) {\n                h = Math.floor(firstTop+i*cellSize)+0.5;\n                context.moveTo(0.0, h);\n                context.lineTo(canvas.width, h);\n            }\n            for (var i=0; i<Math.ceil(canvas.width/cellSize); i++) {\n                h = Math.floor(firstLeft+i*cellSize)+0.5;\n                context.moveTo(h, 0.0);\n                context.lineTo(h, canvas.height);\n            }\n            context.stroke();\n            context.closePath();\n        }\n    }\n\n    function drawCells() {\n        let cell\n        for (let cell of game.livingSet()) {\n            //cell = game.parse(cellString);\n            fillCell(cell, cell.strategy.color);\n        }\n    }\n\n    function drawGrid(cellSize) {\n        clearCanvas()\n        drawGridLines()\n        drawCells()\n    }\n\n    function zoom(event) {\n        event.preventDefault();\n        const zoomOut = event.deltaY > 0\n        // change cellSize 5% for every deltaY unit\n        let zoomDelta = Math.floor(Math.abs(event.deltaY)*5*cellSize/100)\n        // If that change is too small then use 1\n        zoomDelta = Math.max(zoomDelta, 1);\n        const newCellSize = Math.min(Math.max(1, cellSize + (zoomOut ? -1 : 1)*zoomDelta), 200);\n        let [pixelsX, pixelsY] = getPixelsFromMouseEvent(event)\n        pixelsX -= canvas.width/2\n        pixelsY -= canvas.height/2\n        const relX = centerX + pixelsX/cellSize;\n        const relY = centerY + pixelsY/cellSize;\n        centerX = (relX - pixelsX/newCellSize);\n        centerY = (relY - pixelsY/newCellSize);\n        centerX = Math.round(2*centerX)/2;\n        centerY = Math.round(2*centerY)/2;\n        cellSize = newCellSize;\n    }\n\n    let directions = new Set();\n    function onKeyDown(event) {\n        if ((event.keyCode===87)|(event.keyCode===38)) { // w or ArrowUp\n            directions.add('up');\n        } else if ((event.keyCode===83)|(event.keyCode===40)) { //s or ArrowDown\n            directions.add('down');\n        } else if ((event.keyCode===65)|(event.keyCode===37)) { // a or ArrowLeft\n            directions.add('left');\n        } else if ((event.keyCode===68)|(event.keyCode===39)) { //d or ArrowRight\n            directions.add('right');\n        }\n        const delta = 20/cellSize\n        const deltaX = (directions.has('right') ? delta : 0) - (directions.has('left') ? delta : 0)\n        const deltaY = (directions.has('down') ? delta : 0) - (directions.has('up') ? delta : 0)\n        if ((deltaX!==0)|(deltaY!==0)) {\n            if (drawing) {\n                const cells = getCellsBetween(mouseX, mouseY, mouseX+deltaX, mouseY+deltaY)\n                if (cells.length > 0) {\n                    if (drawAlive) {\n                        updateGrid(cells, [])\n                    } else {\n                        updateGrid([], cells)\n                    }\n                }\n                mouseX += deltaX\n                mouseY += deltaY\n            }\n            centerX += deltaX\n            centerY += deltaY\n            drawGrid();\n        }\n    }\n\n    function onKeyUp(event) {\n        if ((event.keyCode===87)|(event.keyCode===38)) { // w or ArrowUp\n            directions.delete('up');\n        } else if ((event.keyCode===83)|(event.keyCode===40)) { //s or ArrowDown\n            directions.delete('down');\n        } else if ((event.keyCode===65)|(event.keyCode===37)) { // a or ArrowLeft\n            directions.delete('left');\n        } else if ((event.keyCode===68)|(event.keyCode===39)) { //d or ArrowRight\n            directions.delete('right');\n        }\n    }\n\n    function coordToCell(cx, cy) {\n        return {\n            r: Math.floor(cy),\n            c: Math.floor(cx),\n        }\n    }\n    function getPixelsFromMouseEvent(event) {\n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        return [x, y]\n    }\n\n\n    function getCoordFromMouseEvent(event) {\n        const [x, y] = getPixelsFromMouseEvent(event)\n        return pixelsToCoord(x, y)\n    }\n\n    function pixelsToCoord(x, y) {\n        const coord = [\n            centerX + (x-1-canvas.width/2 )/cellSize,\n            centerY + (y-1-canvas.height/2)/cellSize,\n        ]\n        return coord\n    }\n\n    function pixelsToCell(x, y) {\n        const [cx, cy] = pixelsToCoord(x, y);\n        return coordToCell(cx, cy)\n    }\n\n    function cellToTopLeftPixels(cell) {\n        const pixels = {\n            x: Math.floor(canvas.width/2  + 1 + (cell.c - centerX)*cellSize),\n            y: Math.floor(canvas.height/2 + 1 + (cell.r - centerY)*cellSize),\n        }\n        return pixels\n    }\n\n    function integersBetween(z1, z2) {\n        const result = []\n        if (z2 > z1) {\n            for (let i=Math.ceil(z1); i<z2; i++) {\n                result.push(i)\n            }\n        } else {\n            for (let i=Math.floor(z1); i>z2; i--) {\n                result.push(i)\n            }\n        }\n        return result\n    }\n\n    function getCellsBetween(x1, y1, x2, y2) {\n        const lx = x2 - x1;\n        const ly = y2 - y1;\n        let innerX, innerY\n        let cells = []\n        // look for points where the line intersects cell boundaries\n        // not guarding against duplicate cells here\n        for (innerX of integersBetween(x1, x2)) {\n            innerY = y1 + ly * (innerX - x1) / lx\n            cells.push(coordToCell(innerX-1, innerY))\n            cells.push(coordToCell(innerX, innerY))\n        }\n        for (innerY of integersBetween(y1, y2)) {\n            innerX = x1 + lx * (innerY - y1) / ly\n            cells.push(coordToCell(innerX, innerY-1))\n            cells.push(coordToCell(innerX, innerY))\n        }\n        return cells\n    }\n\n\n    function handleMouseDown(event) {\n        const [cx, cy] = getCoordFromMouseEvent(event)\n        const cell = coordToCell(cx, cy)\n        drawAlive = !(game.isCellAlive(cell))\n        if (drawAlive) {\n            updateGrid([cell], [])\n        } else {\n            updateGrid([], [cell])\n        }\n        drawing = true\n        mouseX = cx\n        mouseY = cy\n    }\n\n    function handleMouseMove(event) {\n        if (drawing) {\n            const [cx, cy] = getCoordFromMouseEvent(event)\n            const cells = getCellsBetween(mouseX, mouseY, cx, cy)\n            if (cells.length > 0) {\n                if (drawAlive) {\n                    updateGrid(cells, [])\n                } else {\n                    updateGrid([], cells)\n                }\n            }\n            mouseX = cx\n            mouseY = cy\n        }\n    }\n\n    function handleMouseUp(event) {\n        const [cx, cy] = getCoordFromMouseEvent(event)\n        const cell = coordToCell(cx, cy)\n        if (drawAlive) {\n            updateGrid([cell], [])\n        } else {\n            updateGrid([], [cell])\n        }\n        drawing = false\n    }\n\n    // touch handling\n    let ongoingTouches = []\n    let lastTouchTime = 0\n\n    function handleTouchStart(event) {\n        event.preventDefault();\n        for (let touch of event.changedTouches) {\n            ongoingTouches.push({\n                id: touch.identifier,\n                clientX: touch.clientX,\n                clientY: touch.clientY,\n            });\n        }\n        lastTouchTime = performance.now();\n        if (ongoingTouches.length==1) {\n            const [cx, cy] = getCoordFromMouseEvent(ongoingTouches[0])\n            const cell = coordToCell(cx, cy)\n            drawAlive = !(game.isCellAlive(cell))\n            drawing = true;\n        } else if (ongoingTouches.length>1) {\n            drawing = false;\n        }\n    }\n    function handleTouchMove(event) {\n        event.preventDefault();\n        let time = performance.now();\n        if ((time - lastTouchTime >= 50)\n                &&(ongoingTouches.length == 1)\n                &&(drawing)) {\n            // one finger moves - draw\n            const newTouch = event.changedTouches[0]\n            const [cx, cy] = getCoordFromMouseEvent(ongoingTouches[0])\n            const [newcx, newcy] = getCoordFromMouseEvent(newTouch)\n            const cells = getCellsBetween(newcx, newcy, cx, cy)\n            if (cells.length > 0) {\n                if (drawAlive) {\n                    updateGrid(cells, [])\n                } else {\n                    updateGrid([], cells)\n                }\n            }\n            ongoingTouches = [{\n                id: newTouch.identifier,\n                clientX: newTouch.clientX,\n                clientY: newTouch.clientY,\n            }];\n            lastTouchTime = time;\n        } else if ((time - lastTouchTime >= 200)\n                    &&(ongoingTouches.length==2)) {\n            // two fingers move - pan or zoom\n            const ids = ongoingTouches.map(item => item.id);\n            let newTouches = [...ongoingTouches]\n            let index\n            for (let touch of event.changedTouches) {\n                index = ids.indexOf(touch.identifier)\n                newTouches[index] = {\n                    id: touch.identifier,\n                    clientX: touch.clientX,\n                    clientY: touch.clientY,\n                }\n            }\n            // how much did distance in pixels change between fingers\n            // scale cell size that much\n            const oldDistance = Math.sqrt(\n                (ongoingTouches[0].clientX-ongoingTouches[1].clientX)**2\n                +(ongoingTouches[0].clientY-ongoingTouches[1].clientY)**2)\n            const newDistance = Math.sqrt(\n                (newTouches[0].clientX-newTouches[1].clientX)**2\n                +(newTouches[0].clientY-newTouches[1].clientY)**2)\n            const newCellSize = Math.max(1, Math.round(newDistance*cellSize/oldDistance))\n            // how much did fingers move from their previous position?\n            // move the screen in that average direction\n            const [cx0, cy0] = getCoordFromMouseEvent(ongoingTouches[0])\n            const [cx1, cy1] = getCoordFromMouseEvent(ongoingTouches[1])\n            cellSize = newCellSize\n            const [newcx0, newcy0] = getCoordFromMouseEvent(newTouches[0])\n            const [newcx1, newcy1] = getCoordFromMouseEvent(newTouches[1])\n            const deltaX = 0.5*(newcx0-cx0+newcx1-cx1)\n            const deltaY = 0.5*(newcy0-cy0+newcy1-cy1)\n            centerX = centerX-deltaX;\n            centerY = centerY-deltaY;\n            drawGrid()\n            ongoingTouches = newTouches\n            }\n    }\n\n    function handleTouchEnd(event) {\n        event.preventDefault();\n        if (drawing && (ongoingTouches.length===1)) {\n            const [cx, cy] = getCoordFromMouseEvent(event.changedTouches[0])\n            const cell = coordToCell(cx, cy)\n            if (drawAlive) {\n                updateGrid([cell], [])\n            } else {\n                updateGrid([], [cell])\n            }\n            drawing = false;\n        }\n        for (let touch of event.changedTouches) {\n            ongoingTouches = ongoingTouches.filter(item => item.id!==touch.identifier)\n        }\n        lastTouchTime = performance.now();\n    }\n\n    function fillCell(cell, color) {\n        context.fillStyle = color;\n        const pixels = cellToTopLeftPixels(cell)\n        context.fillRect(\n            pixels.x, pixels.y,\n            cellSize-(cellSize<=2 ? 0.0 : 1.0),\n            cellSize-(cellSize<=2 ? 0.0 : 1.0)\n        );\n    }\n\n    function updateGrid(births, deaths) {\n        let t0 = performance.now()\n        if ((births.length==0)&(deaths.length===0)) {stop()}\n        game.update(births, deaths);\n        for (let cell of births) {\n            fillCell(cell, cell.strategy.color)\n        }\n        for (let cell of deaths) {\n            fillCell(cell, backgroundColor)\n        }\n        drawTime=Math.round(performance.now()-t0);\n        numCells = game.livingSet().size;\n    }\n\n    function step() {\n        let t0 = performance.now()\n        let births, deaths\n        [births, deaths] = game.step();\n        stepTime = Math.round(performance.now()-t0);\n        updateGrid(births, deaths);\n    }\n\n    function clear() {\n        game.clear()\n        drawGrid();\n        numCells = game.livingSet().size;\n    }\n\n    function run() {\n        if (!running) {\n            timerId = setInterval(() => step(), 10000/speed);\n            running = true;\n        }\n    }\n\n    function stop() {\n        if (running) {\n            clearInterval(timerId)\n            running = false;\n        }\n    }\n\n    function set_speed(speed) {\n        if (running) {\n            stop()\n            run()\n        }\n    }\n\n    async function onResize() {\n        canvas.width=10\n        canvas.height=10\n        const rect = canvas.parentNode.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n        drawGrid(cellSize)\n    }\n        onMount(async () => {\n            context = canvas.getContext(\"2d\");\n            // There's some resizing going on in the beginning\n            // If I call onResize here it works like half the time\n            // The other half - size of canvas stays 150*300\n            // Or window width*10\n            // This timeout is an ugly hack (but works?...)\n            setTimeout(onResize,42);\n            // onResize()\n        });\n\n    $: if (canvas) {\n        drawGrid(cellSize);\n    }\n    $: set_speed(speed);\n</script>\n\n<svelte:window on:keydown={onKeyDown} on:keyup={onKeyUp} on:resize={onResize}/>\n<div class=\"controls\">\n    <div class=\"row\">\n        <button\n            type=\"button\"\n            name=\"help\"\n            title=\"Show help\"\n            on:click={()=>helpVisible=!helpVisible}\n            >?</button>\n        <button on:click={clear} title=\"Clear all cells from grid\">Clear</button>\n        <button on:click={step} disabled={running}>\n            Step\n        </button>\n        <button on:click={running ? stop : run}>\n            {running ? 'Stop' : 'Run'}\n        </button>\n    </div>\n    <div class=\"row\">\n        <label for=\"speed\">Speed</label>\n        <input id=\"speed\" type=\"range\" min=\"5\" max=\"500\" step=\"1\" bind:value={speed} />\n    </div>\n    <div class=\"row\">\n        <div>\n            cells:<br/>{numCells}\n        </div>\n        <div>\n            step:<br/>{stepTime} ms\n        </div>\n        <div>\n            draw:<br/>{drawTime} ms\n        </div>\n    </div>\n    {#if helpVisible}\n    <ul>\n        <li><a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\">Conway's Game of Life</a>.</li>\n        <li>Click or touch and drag to draw shapes</li>\n        <li>Press Run to see them evolve</li>\n        <li>Use W,A,S,D or arrows to move around, mouse wheel to zoom</li>\n        <li>Or touch with two fingers to pan and zoom</li>\n    </ul>\n    {/if}\n</div>\n<canvas id=\"gridCanvas\"\n                class=\"gridCanvas\"\n                bind:this={canvas}\n                on:mouseup={handleMouseUp}\n                on:mousedown={handleMouseDown}\n                on:mousemove={handleMouseMove}\n                on:wheel={zoom}\n                on:touchstart={handleTouchStart}\n                on:touchmove={handleTouchMove}\n                on:touchend={handleTouchEnd}\n                on:touchcancel={handleTouchEnd}\n                ></canvas>\n\n<style>\n    div.controls {\n        display:flex;\n        flex-direction:column;\n        position:absolute;\n        top: 5px;\n        left: 5px;\n        max-width:250px;\n        padding: 0 5px;\n        background:rgba(180,180,180,0.8);\n        border-radius: 5px;\n    }\n   canvas {\n      display: block;\n   }\n    button {\n        width: 3.5em;\n        border-radius:5px;\n        background:#bbb;\n    }\n    div.row {\n        display:flex;\n        flex-direction:row;\n        justify-content: space-between;\n        align-items:center;\n        padding: 5px 0;\n    }\n    div.row>div {\n        flex: 1 1 0px;\n    }\n</style>\n","import App from './App.svelte';\n\nvar app = new App({\n    target: document.body\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","i","length","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","on_destroy","context","Map","callbacks","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","c","intro","block","delete","local","m","new_on_destroy","map","filter","mount_component","Cell","[object Object]","r","strategy","this","alive","Helper","cellKey","cellString","parseCell","IpdScore","cell","fightCount","winByStrategyCount","scoreByStrategyCount","winCount","score","versusCell","versusScore","byStratCounter","get","set","byStratScore","otherScore","split","parseInt","cell1","cell2","replicaCounts","strategies","alpha","Math","PI","arenaDiameter","k","x","ceil","cos","y","sin","indice","floor","position","round","pow","console","debug","dx","baseDiameter","dy","sqrt","environment","spawn","NEIGHBORHOOD","roundCount","boundary","livings","neigborhoodsMap","fightsDone","scoreboard","leaderboard","fightResultCacheDisabled","fightResultCache","initArena","key","neighborhood","distancesToCenter","dc","dr","nr","nc","midDistanceToCenter","distanceToCenter","reducedDistanceToCenter","sort","reduced","dist","ncellKey","neighborhoods","babies","neigborhoodsKeys","neighborKey","nCell","baby","fightKey","strategy1Counter","strategy2Counter","fightingStratsKey","strategy1","strategy2","strategy1Plays","strategy2Plays","play1","play","play2","score1","addScore","score2","sameStratCount","localTotalScore","neighborByStratCountMap","neighbor","count","nScore","neighborByStratCounts","values","badScoreVersusStrat","neighborCount","strat","level","ncellScore","isGreaterThan","ncell","self","births","deaths","RANDOM_STRATEGY","fight","babiesByParentMap","parentsByBabyMap","isDying","isGivingBirth","giveBirth","concurrentParrents","babyKey","highestScore","winningCell","kill","info","COOPERATIVE_STRATEGY","color","roundNumber","myPlays","otherPlays","DEFECTIVE_STRATEGY","DONNANT_DONNANT_STRATEGY","PER_CD_STRATEGY","PER_CCD_STRATEGY","plays","random","game","step","livingSet","isCellAlive","coordToCell","cx","cy","integersBetween","z1","z2","result","getCellsBetween","x1","y1","x2","y2","lx","ly","innerX","innerY","cells","canvas","timerId","mouseX","mouseY","cellSize","centerX","centerY","stepTime","drawTime","speed","running","drawing","drawAlive","helpVisible","numCells","drawGridLines","centerLeft","width","firstLeft","centerTop","height","firstTop","h","strokeStyle","beginPath","moveTo","lineTo","stroke","closePath","drawGrid","clearRect","fillStyle","fillRect","fillCell","drawCells","directions","getPixelsFromMouseEvent","rect","getBoundingClientRect","clientX","left","clientY","top","getCoordFromMouseEvent","pixelsToCoord","ongoingTouches","lastTouchTime","pixels","cellToTopLeftPixels","updateGrid","t0","performance","now","stop","size","setInterval","clearInterval","onResize","getContext","setTimeout","preventDefault","zoomOut","deltaY","zoomDelta","abs","max","newCellSize","min","pixelsX","pixelsY","keyCode","delta","deltaX","touch","changedTouches","id","identifier","time","newTouch","newcx","newcy","ids","item","index","newTouches","indexOf","oldDistance","newDistance","cx0","cy0","cx1","cy1","newcx0","newcy0","newcx1","newcy1","undefined","detaching","d","destroy_component","$destroy","type","splice","body"],"mappings":"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"}